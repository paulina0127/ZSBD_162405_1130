-- 1. Stwórz tabelę archiwum_departamentów (id, nazwa, data_zamknięcia, ostatni_manager jako imię i nazwisko). Po usunięciu departamentu dodać odpowiedni rekord do tej tabeli.
CREATE TABLE department_archive (
    id                NUMBER PRIMARY KEY,
    name              VARCHAR2(100),
    closure_date      DATE,
    last_manager      VARCHAR2(200)
);

CREATE OR REPLACE TRIGGER trg_department_archive
AFTER DELETE ON departments
FOR EACH ROW
DECLARE
    v_manager_name VARCHAR2(200);
BEGIN
    SELECT first_name || ' ' || last_name
    INTO v_manager_name
    FROM employees
    WHERE employee_id = :OLD.manager_id;

    INSERT INTO department_archive (
        id,
        name,
        closure_date,
        last_manager
    ) VALUES (
        :OLD.department_id,
        :OLD.department_name,
        SYSDATE,
        v_manager_name
    );
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        INSERT INTO department_archive (
            id,
            name,
            closure_date,
            last_manager
        ) VALUES (
            :OLD.department_id,
            :OLD.department_name,
            SYSDATE,
            'Brak danych'
        );
END;
/

-- 2. W razie UPDATE i INSERT na tabeli employees, sprawdzić czy zarobki łapią się w widełkach 2000 - 26000. Jeśli nie łapią się - zabronić dodania. Dodać tabelę złodziej(id, USER, czas_zmiany), której będą wrzucane logi, jeśli będzie próba dodania, bądź zmiany wynagrodzenia poza widełki.
CREATE TABLE thief (
    id            NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username      VARCHAR2(100),
    change_time   TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE OR REPLACE TRIGGER employees_salary_check
BEFORE INSERT OR UPDATE ON employees
FOR EACH ROW
DECLARE
    PRAGMA AUTONOMOUS_TRANSACTION;
    v_username VARCHAR2(100);
BEGIN
    IF :NEW.salary < 2000 OR :NEW.salary > 26000 THEN
        v_username := SYS_CONTEXT('USERENV', 'SESSION_USER');

        INSERT INTO thief (username) VALUES (v_username);
        COMMIT; 

        RAISE_APPLICATION_ERROR(-20001, 'Salary must be between 2000 and 26000.');
    END IF;
END;
/

UPDATE employees SET salary = 27000 WHERE employee_id = 100 ;
SELECT * FROM thief;

-- 3. Stwórz sekwencję i wyzwalacz, który będzie odpowiadał za auto_increment w tabeli employees.
CREATE SEQUENCE seq_employee_id
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE OR REPLACE TRIGGER trg_auto_employee_id
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
    IF :NEW.employee_id IS NULL THEN
        :NEW.employee_id := seq_employee_id.NEXTVAL;
    END IF;
END;
/

INSERT INTO employees (first_name, last_name, email, hire_date, job_id)
VALUES ('Adam', 'Nowak', 'nowak@example.com', DATE '2025-05-05', 10);

SELECT * from employees WHERE last_name='Nowak';

-- 4. Stwórz wyzwalacz, który zabroni dowolnej operacji na tabeli JOB_GRADES (INSERT, UPDATE, DELETE).
CREATE OR REPLACE TRIGGER trg_block_job_grades
BEFORE INSERT OR UPDATE OR DELETE ON JOB_GRADES
BEGIN
    RAISE_APPLICATION_ERROR(-20002, 'Modifications to JOB_GRADES are not allowed.');
END;
/

UPDATE job_grades SET min_salary=1000 WHERE grade='A';

-- 5. Stwórz wyzwalacz, który przy próbie zmiany max i min salary w tabeli jobs zostawia stare wartości.
CREATE OR REPLACE TRIGGER trg_prevent_salary_change
BEFORE UPDATE ON jobs
FOR EACH ROW
BEGIN
    IF :NEW.min_salary != :OLD.min_salary THEN
        :NEW.min_salary := :OLD.min_salary;
    END IF;

    IF :NEW.max_salary != :OLD.max_salary THEN
        :NEW.max_salary := :OLD.max_salary;
    END IF;
END;
/

UPDATE jobs
SET min_salary = 10000, max_salary = 20000
WHERE job_id = 'IT_PROG';

SELECT * from jobs WHERE job_id = 'IT_PROG';